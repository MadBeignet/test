  @Override
    protected Location generateSpawnLocation() {
        if(_playersToAvoid.size() != 2) {
            return super.generateSpawnLocation();
        }

        // This is not necessarily the actual home/away seeker. Do not assume.
        Player homeSeeker, awaySeeker;

        try {
            homeSeeker = Bukkit.getPlayer((UUID) _playersToAvoid.toArray()[0]);
            awaySeeker = Bukkit.getPlayer((UUID) _playersToAvoid.toArray()[1]);

            if(homeSeeker == null || awaySeeker == null) {
                throw new NullPointerException("Home or away seeker is null");
            }
        } catch(Exception exception) {
            return super.generateSpawnLocation();
        }


        //TODO: Generate a safe Y value
        //TODO: Ensure the Snitch doesn't break if it spawns in chunks without players nearby
        //TODO: Ensure Snitch does not spawn within a block

        // Diagram: https://media.discordapp.net/attachments/779812032920158228/779827414636953600/image0.png

        // These are the variables in which the Z value of a circle intersects the X line.
        double xIntersecHomePosZ = 250;
        double xIntersecHomeNegZ = -xIntersecHomePosZ;
        double xIntersecAwayPosZ = 250;
        double xIntersecAwayNegZ = -xIntersecAwayPosZ;

        // ???
        int range;

        // This is the coordinates the Snitch can spawn.
        // I.e. between the barrier walls. It is 1 block inwards from the barrier walls.
        int borderMinZ = -292;
        int borderMaxZ = 297;
        int borderMinX = -312;
        int borderMaxX = 277;

        // It cannot be assumed these are the actual home/away. They are just the two different seekers.
        int homeSeekerX = homeSeeker.getLocation().getBlockX();
        int homeSeekerZ = homeSeeker.getLocation().getBlockZ();
        int awaySeekerX = awaySeeker.getLocation().getBlockX();
        int awaySeekerZ = awaySeeker.getLocation().getBlockZ();

        // Because the arena is about 600 wide each way and each seeker takes up 200 each optimally, then the snitch can spawn on any x value
        int x = (int) (Math.random() * (borderMaxX - borderMinX) + borderMinX + 1);

        // So in this first part I basically just created the equation of a circle and found both potential points using the random x value
        double homeExistence = Math.pow(range, 2) - Math.pow(x - homeSeekerX, 2);
        if (homeExistence >= 0) {
            xIntersecHomePosZ= ((Math.sqrt(homeExistence)) + homeSeekerZ);
            xIntersecHomeNegZ = (((-(Math.sqrt(homeExistence)))) + homeSeekerZ);

            if (xIntersecHomePosZ> borderMaxZ) {
                xIntersecHomePosZ= borderMaxZ; // basically just makes sure that the values on the circle don't go outside of the map
            }
            if (xIntersecHomeNegZ < borderMinZ) {
                xIntersecHomeNegZ = borderMinZ;
            }
        }

        // same as above but for away seeker
        double awayExistence  = Math.pow(range, 2) - Math.pow(x - awaySeekerX, 2);
        if (awayExistence  >= 0) {
            xIntersecAwayPosZ = (Math.sqrt(Math.abs(awayExistence ))) + awaySeekerZ;
            xIntersecAwayNegZ = ((-(Math.sqrt(Math.abs(awayExistence )))) + awaySeekerZ);
            if (xIntersecAwayPosZ > borderMaxZ) {
                xIntersecAwayPosZ = borderMaxZ; // again, can't be a point outside of the map
            }
            if (xIntersecAwayNegZ < borderMinZ) {
                xIntersecAwayNegZ = borderMinZ;
            }
        }

        int homeSeekerZRange = 0, awaySeekerZRange = 0;
        // 84-124 is tests for how the range (areas where the snitch cannot spawn) should be interpreted
        // if away circle doesn't exist but home does this created a problem so the -500 was needed
        // testing for overlap between the circles
        if (xIntersecHomePosZ> xIntersecAwayNegZ && xIntersecAwayNegZ != -500 && Math.abs(xIntersecHomePosZ- xIntersecAwayNegZ) < Math.abs(xIntersecHomePosZ- xIntersecHomeNegZ)) {
            homeSeekerZRange = (int) (Math.abs(xIntersecHomePosZ- xIntersecHomeNegZ) - (Math.abs(xIntersecHomePosZ- xIntersecAwayNegZ))) + 1;
            awaySeekerZRange = (int) Math.abs(xIntersecAwayPosZ - xIntersecAwayNegZ) + 1;

        }

        // same as above
        if (xIntersecAwayPosZ > xIntersecHomeNegZ && xIntersecHomeNegZ != -500 && Math.abs(xIntersecAwayPosZ - xIntersecHomeNegZ) < Math.abs(xIntersecAwayPosZ - xIntersecAwayNegZ)) {
            homeSeekerZRange = (int) (Math.abs(xIntersecHomePosZ- xIntersecHomeNegZ) - (Math.abs(xIntersecAwayPosZ - xIntersecHomeNegZ))) + 1;
            awaySeekerZRange = (int) Math.abs(xIntersecAwayPosZ - xIntersecAwayNegZ) + 1;

        }

        // checks if one range is inside of the other range and accounts for that
        boolean homeAwayCirclesOverlap  = (xIntersecHomePosZ>= xIntersecAwayPosZ && xIntersecHomeNegZ <= xIntersecAwayNegZ) || (xIntersecAwayPosZ >= xIntersecHomePosZ&& xIntersecAwayNegZ <= xIntersecHomeNegZ);
        if ((xIntersecHomeNegZ != -500 && xIntersecAwayNegZ != -500) && homeAwayCirclesOverlap ) {
            if (Math.abs(xIntersecHomePosZ- xIntersecHomeNegZ) > Math.abs(xIntersecAwayPosZ - xIntersecAwayNegZ)) {
                homeSeekerZRange = (int) Math.abs(xIntersecHomePosZ- xIntersecHomeNegZ + 1) / 2;
                awaySeekerZRange = (int) Math.abs(xIntersecHomePosZ- xIntersecHomeNegZ + 1) / 2;
            } else {

                homeSeekerZRange = (int) Math.abs(xIntersecAwayPosZ - xIntersecAwayNegZ + 1) / 2;
                awaySeekerZRange = (int) Math.abs(xIntersecAwayPosZ - xIntersecAwayNegZ + 1) / 2;
            }
        }

        // this one basically just makes sure there is no overlap and that the bigger value on one circle is less than the smaller value on another
        if ((xIntersecAwayNegZ != -500 && xIntersecHomeNegZ != -500) && (xIntersecHomePosZ< xIntersecAwayNegZ || xIntersecAwayPosZ <= xIntersecHomeNegZ)) {
            homeSeekerZRange = (int) Math.abs(xIntersecHomeNegZ - xIntersecHomePosZ) + 1;
            awaySeekerZRange = (int) Math.abs(xIntersecAwayNegZ - xIntersecAwayPosZ) + 1;
        }

        // this one is for if home circle doesn't exist, homeSeekerZRange = 0 in this case
        if (homeExistence < 0 && awayExistence  >= 0) {
            awaySeekerZRange = (int) Math.abs(xIntersecAwayNegZ - xIntersecAwayPosZ) + 1;
        }

        // this one is for if away circle doesn't exist, awaySeekerZRange = 0 in this case
        if (awayExistence  < 0 && homeExistence >= 0) {
            homeSeekerZRange = (int) Math.abs(xIntersecHomeNegZ - xIntersecHomePosZ) + 1;
        }

        // this basically calculates the number of spawnable places for the snitch in the one line of the random x value entered from main method
        int spawnz = (int) (Math.random() * (borderMaxZ - borderMinZ - homeSeekerZRange - awaySeekerZRange) + borderMinZ);

        // all below is the area where spawnz is tested whether it needs to be shifted
        //this is basically for points where the one range is around the other, but the point (spawnz) is inside one or both of the ranges
        if (homeAwayCirclesOverlap  && ((spawnz < xIntersecHomePosZ&& spawnz > xIntersecHomeNegZ) || (spawnz < xIntersecAwayPosZ && spawnz > xIntersecAwayNegZ))) {
            spawnz += homeSeekerZRange + awaySeekerZRange;
        }

        // makes sure both circles exist in the line and then sees if the point picked is in the unspawnable range, if so, adds the range of the circle on that line
        if ((awaySeekerZRange != 0 && homeSeekerZRange > 0) && spawnz <= xIntersecHomePosZ&& spawnz >= xIntersecHomeNegZ) {
            //adds the range of the other circle if it runs into it after being added above
            spawnz += homeSeekerZRange;

            if (spawnz <= xIntersecAwayPosZ && spawnz >= xIntersecAwayNegZ) {
                spawnz += awaySeekerZRange;
            }
        }

        // same thing as above just flip flopped
        if ((awaySeekerZRange != 0 && homeSeekerZRange > 0) && spawnz <= xIntersecAwayPosZ && spawnz >= xIntersecAwayNegZ) {
            spawnz += awaySeekerZRange;

            if (spawnz <= xIntersecHomePosZ&& spawnz >= xIntersecHomeNegZ) {
                spawnz += homeSeekerZRange;
            }
        }

        // because I separated homeSeekerZRange and awaySeekerZRange when the circles overlapped, one was negative, so I made another statement because it would jump 160 blocks and not go back
        if (homeSeekerZRange < 0 && (spawnz <= xIntersecHomePosZ&& spawnz >= xIntersecHomeNegZ || spawnz <= xIntersecAwayPosZ && spawnz >= xIntersecAwayNegZ)) {
            spawnz += homeSeekerZRange + awaySeekerZRange;
        }

        // here we reach the tests for nonexistent circles and if the z value needs to be shifted by the range of the existent circle
        if (homeSeekerZRange == 0 && awaySeekerZRange != 0 && spawnz <= xIntersecAwayPosZ && spawnz >= xIntersecAwayNegZ) {
            spawnz += awaySeekerZRange;
        }

        if (awaySeekerZRange == 0 && homeSeekerZRange != 0 && spawnz <= xIntersecHomePosZ&& spawnz >= xIntersecHomeNegZ) {
            spawnz += homeSeekerZRange;
        }

        // obviously no need to test if the ranges are both 0 because whatever random z value picked from the original spawnz equation would work
        return new Location(FieldManager.MANAGER.getField().getWorld(), x, 70, spawnz); //returns the value for the x and z coordinate that the snitch should spawn at
    }
